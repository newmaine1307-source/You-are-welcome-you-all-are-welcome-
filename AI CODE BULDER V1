#!/usr/bin/env python3
"""
Real AI Smart Contract Builder Agent not yet done 
"""

import os
import sys
import json
import asyncio
import aiohttp
import logging
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime
import hashlib
import subprocess
import tempfile
import shutil
from dataclasses import dataclass
from enum import Enum

# Core blockchain and crypto imports
from web3 import Web3
from eth_account import Account
from eth_account.hdaccount import generate_mnemonic
from bip32 import BIP32
import solcx
from solcx import compile_source, install_solc

# Security and encryption
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
import base64

# FastAPI and async
from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
from pydantic import BaseModel

# Database
import sqlite3
from contextlib import contextmanager

# Environment management
from dotenv import load_dotenv
load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('ai_contract_builder.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger("AIContractBuilder")

class ContractLanguage(Enum):
    SOLIDITY = "solidity"
    VYPER = "vyper"

class NetworkConfig(Enum):
    MAINNET = {"name": "mainnet", "chain_id": 1, "rpc_key": "MAINNET_RPC_URL"}
    POLYGON = {"name": "polygon", "chain_id": 137, "rpc_key": "POLYGON_RPC_URL"}
    BSC = {"name": "bsc", "chain_id": 56, "rpc_key": "BSC_RPC_URL"}
    ARBITRUM = {"name": "arbitrum", "chain_id": 42161, "rpc_key": "ARBITRUM_RPC_URL"}
    SEPOLIA = {"name": "sepolia", "chain_id": 11155111, "rpc_key": "SEPOLIA_RPC_URL"}

@dataclass
class AIConfig:
    name: str
    api_key: str
    endpoint: str
    model: str

# Your original SecureWalletManager - keeping intact
class SecureWalletManager:
    """Secure HD Wallet Manager with encryption"""
    
    def __init__(self, data_dir: Path):
        self.data_dir = data_dir
        self.wallets_dir = data_dir / "wallets"
        self.wallets_dir.mkdir(parents=True, exist_ok=True)
        self.encryption_key = self._get_or_create_master_key()
        
    def _get_or_create_master_key(self) -> bytes:
        """Get or create master encryption key"""
        key_file = self.data_dir / "master.key"
        if key_file.exists():
            with open(key_file, 'rb') as f:
                return f.read()
        else:
            key = get_random_bytes(32)
            with open(key_file, 'wb') as f:
                f.write(key)
            os.chmod(key_file, 0o600)
            return key
    
    def _encrypt_data(self, data: str) -> str:
        """Encrypt sensitive data"""
        cipher = AES.new(self.encryption_key, AES.MODE_GCM)
        ciphertext, tag = cipher.encrypt_and_digest(data.encode('utf-8'))
        encrypted = cipher.nonce + tag + ciphertext
        return base64.b64encode(encrypted).decode('utf-8')
    
    def _decrypt_data(self, encrypted_data: str) -> str:
        """Decrypt sensitive data"""
        data = base64.b64decode(encrypted_data)
        nonce, tag, ciphertext = data[:16], data[16:32], data[32:]
        cipher = AES.new(self.encryption_key, AES.MODE_GCM, nonce=nonce)
        return cipher.decrypt_and_verify(ciphertext, tag).decode('utf-8')
    
    def create_wallet(self, wallet_name: str, mnemonic: str = None) -> Dict[str, Any]:
        """Create new HD wallet"""
        if mnemonic is None:
            mnemonic = generate_mnemonic(128)
        
        bip32 = BIP32.from_mnemonic(mnemonic)
        
        # Derive first account
        private_key = bip32.get_privkey_from_path("m/44'/60'/0'/0/0")
        account = Account.from_key(private_key)
        
        wallet_data = {
            "name": wallet_name,
            "mnemonic": self._encrypt_data(mnemonic),
            "accounts": {
                "0": {
                    "address": account.address,
                    "private_key": self._encrypt_data(private_key.hex()),
                    "path": "m/44'/60'/0'/0/0"
                }
            },
            "created_at": datetime.utcnow().isoformat()
        }
        
        wallet_file = self.wallets_dir / f"{wallet_name}.json"
        with open(wallet_file, 'w') as f:
            json.dump(wallet_data, f, indent=2)
        
        os.chmod(wallet_file, 0o600)
        logger.info(f"Created wallet: {wallet_name} with address: {account.address}")
        
        return {
            "wallet_name": wallet_name,
            "address": account.address,
            "mnemonic": mnemonic
        }
    
    def get_wallet(self, wallet_name: str) -> Optional[Dict[str, Any]]:
        """Get wallet data"""
        wallet_file = self.wallets_dir / f"{wallet_name}.json"
        if not wallet_file.exists():
            return None
        
        with open(wallet_file, 'r') as f:
            return json.load(f)
    
    def get_private_key(self, wallet_name: str, account_index: int = 0) -> Optional[str]:
        """Get decrypted private key"""
        wallet = self.get_wallet(wallet_name)
        if not wallet or str(account_index) not in wallet["accounts"]:
            return None
        
        encrypted_key = wallet["accounts"][str(account_index)]["private_key"]
        return self._decrypt_data(encrypted_key)

# Enhanced AIContractGenerator with proper AI integration
class AIContractGenerator:
    """Multi-AI contract generation system with real AI capabilities"""
    
    def __init__(self):
        self.ai_configs = self._load_ai_configs()
        
    def _load_ai_configs(self) -> List[AIConfig]:
        """Load AI service configurations"""
        configs = []
        
        # OpenAI Configuration
        if os.getenv('OPENAI_API_KEY'):
            configs.append(AIConfig(
                name="openai",
                api_key=os.getenv('OPENAI_API_KEY'),
                endpoint="https://api.openai.com/v1/chat/completions",
                model="gpt-4-turbo"
            ))
        
        # Anthropic Configuration
        if os.getenv('ANTHROPIC_API_KEY'):
            configs.append(AIConfig(
                name="anthropic",
                api_key=os.getenv('ANTHROPIC_API_KEY'),
                endpoint="https://api.anthropic.com/v1/messages",
                model="claude-3-5-sonnet-20241022"
            ))
        
        # DeepSeek Configuration
        if os.getenv('DEEPSEEK_API_KEY'):
            configs.append(AIConfig(
                name="deepseek",
                api_key=os.getenv('DEEPSEEK_API_KEY'),
                endpoint="https://api.deepseek.com/v1/chat/completions",
                model="deepseek-chat"
            ))
        
        logger.info(f"Loaded {len(configs)} AI configurations")
        return configs
    
    async def generate_contract_with_ai(self, directive: str, ai_name: str = None) -> Dict[str, Any]:
        """Generate contract using specific AI or best available"""
        if ai_name:
            config = next((c for c in self.ai_configs if c.name == ai_name), None)
            if not config:
                raise ValueError(f"AI configuration '{ai_name}' not found")
            return await self._call_ai_service(config, directive)
        
        # Try all AIs and return best result
        results = []
        for config in self.ai_configs:
            try:
                result = await self._call_ai_service(config, directive)
                results.append(result)
            except Exception as e:
                logger.error(f"AI {config.name} failed: {e}")
        
        if not results:
            raise RuntimeError("All AI services failed")
        
        return results[0]
    
    async def _call_ai_service(self, config: AIConfig, directive: str) -> Dict[str, Any]:
        """Call specific AI service"""
        prompt = self._build_contract_prompt(directive)
        
        if config.name == "openai":
            return await self._call_openai(config, prompt)
        elif config.name == "anthropic":
            return await self._call_anthropic(config, prompt)
        elif config.name == "deepseek":
            return await self._call_deepseek(config, prompt)
        else:
            raise ValueError(f"Unknown AI service: {config.name}")
    
    def _build_contract_prompt(self, directive: str) -> str:
        """Build comprehensive contract generation prompt"""
        return f"""
You are an expert Solidity smart contract developer. Generate a complete, production-ready smart contract based on this directive:

DIRECTIVE: {directive}

REQUIREMENTS:
1. Use Solidity 0.8.26 or latest compatible version
2. Import and use latest  OpenZeppelin contracts where appropriate how suggested with no alterations 
3. Follow security best practices (checks-effects-interactions, reentrancy protection)
4. Include comprehensive error handling with custom errors
5. Add detailed NatSpec documentation
6. Implement proper access controls
7. Include events for all state changes
8. Use gas-efficient patterns
9. Add upgrade patterns if requested

DELIVERABLES:
1. Complete contract source code
2. Constructor parameters explanation
3. Main functions overview
4. Security considerations
5. Deployment instructions
6. Test scenarios

Generate ONLY valid, compilable Solidity code with proper imports and structure.
"""
    
    async def _call_openai(self, config: AIConfig, prompt: str) -> Dict[str, Any]:
        """Call OpenAI API"""
        headers = {
            "Authorization": f"Bearer {config.api_key}",
            "Content-Type": "application/json"
        }
        
        data = {
            "model": config.model,
            "messages": [
                {"role": "system", "content": "You are an expert Solidity developer."},
                {"role": "user", "content": prompt}
            ],
            "max_tokens": 4000,
            "temperature": 0.1
        }
        
        async with aiohttp.ClientSession() as session:
            async with session.post(config.endpoint, headers=headers, json=data) as response:
                result = await response.json()
                
                if response.status != 200:
                    raise RuntimeError(f"OpenAI API error: {result}")
                
                content = result["choices"][0]["message"]["content"]
                return {
                    "ai_service": "openai",
                    "contract_code": self._extract_solidity_code(content),
                    "full_response": content
                }
    
    async def _call_anthropic(self, config: AIConfig, prompt: str) -> Dict[str, Any]:
        """Call Anthropic API"""
        headers = {
            "x-api-key": config.api_key,
            "Content-Type": "application/json",
            "anthropic-version": "2023-06-01"
        }
        
        data = {
            "model": config.model,
            "messages": [{"role": "user", "content": prompt}],
            "max_tokens": 4000
        }
        
        async with aiohttp.ClientSession() as session:
            async with session.post(config.endpoint, headers=headers, json=data) as response:
                result = await response.json()
                
                if response.status != 200:
                    raise RuntimeError(f"Anthropic API error: {result}")
                
                content = result["content"][0]["text"]
                return {
                    "ai_service": "anthropic",
                    "contract_code": self._extract_solidity_code(content),
                    "full_response": content
                }
    
    async def _call_deepseek(self, config: AIConfig, prompt: str) -> Dict[str, Any]:
        """Call DeepSeek API"""
        headers = {
            "Authorization": f"Bearer {config.api_key}",
            "Content-Type": "application/json"
        }
        
        data = {
            "model": config.model,
            "messages": [
                {"role": "system", "content": "You are an expert Solidity developer."},
                {"role": "user", "content": prompt}
            ],
            "max_tokens": 4000,
            "temperature": 0.1
        }
        
        async with aiohttp.ClientSession() as session:
            async with session.post(config.endpoint, headers=headers, json=data) as response:
                result = await response.json()
                
                if response.status != 200:
                    raise RuntimeError(f"DeepSeek API error: {result}")
                
                content = result["choices"][0]["message"]["content"]
                return {
                    "ai_service": "deepseek",
                    "contract_code": self._extract_solidity_code(content),
                    "full_response": content
                }
    
    def _extract_solidity_code(self, text: str) -> str:
        """Extract Solidity code from AI response"""
        import re
        
        # First try to find ```solidity blocks
        solidity_match = re.search(r'```solidity\n(.*?)```', text, re.DOTALL)
        if solidity_match:
            return solidity_match.group(1).strip()
        
        # Try generic code blocks
        code_match = re.search(r'```\n(.*?)```', text, re.DOTALL)
        if code_match:
            code = code_match.group(1).strip()
            if 'pragma solidity' in code or 'contract ' in code:
                return code
        
        # Fallback: look for contract definitions
        contract_match = re.search(r'(pragma solidity.*?(?=\n\n|\Z))', text, re.DOTALL)
        if contract_match:
            return contract_match.group(1).strip()
        
        return text.strip()

# Your original ContractCompiler - keeping intact
class ContractCompiler:
    """Solidity contract compilation and testing"""
    
    def __init__(self, workspace_dir: Path):
        self.workspace_dir = workspace_dir
        self.contracts_dir = workspace_dir / "contracts"
        self.build_dir = workspace_dir / "build"
        self.test_dir = workspace_dir / "test"
        
        # Create directories
        for dir_path in [self.contracts_dir, self.build_dir, self.test_dir]:
            dir_path.mkdir(parents=True, exist_ok=True)
        
        # Install latest Solidity compiler
        self._setup_solc()
    
    def _setup_solc(self):
        """Setup Solidity compiler"""
        try:
            # Install latest version
            latest_version = solcx.get_installable_solc_versions()[0]
            install_solc(latest_version)
            solcx.set_solc_version(latest_version)
            logger.info(f"Installed Solidity compiler version: {latest_version}")
        except Exception as e:
            logger.error(f"Failed to setup Solidity compiler: {e}")
            raise
    
    def compile_contract(self, contract_code: str, contract_name: str) -> Dict[str, Any]:
        """Compile Solidity contract"""
        try:
            # Write contract to file
            contract_file = self.contracts_dir / f"{contract_name}.sol"
            with open(contract_file, 'w') as f:
                f.write(contract_code)
            
            # Compile with dependencies
            compiled_sol = compile_source(
                contract_code,
                output_values=['abi', 'bin', 'bin-runtime'],
                solc_version=None,
                optimize=True,
                optimize_runs=200
            )
            
            # Extract compilation results
            results = {}
            for contract_id, contract_interface in compiled_sol.items():
                contract_key = contract_id.split(':')[-1]
                results[contract_key] = {
                    'abi': contract_interface['abi'],
                    'bytecode': contract_interface['bin'],
                    'runtime_bytecode': contract_interface['bin-runtime']
                }
            
            # Save compilation artifacts
            build_file = self.build_dir / f"{contract_name}.json"
            with open(build_file, 'w') as f:
                json.dump(results, f, indent=2)
            
            logger.info(f"Successfully compiled contract: {contract_name}")
            return results
            
        except Exception as e:
            logger.error(f"Compilation failed for {contract_name}: {e}")
            raise
    
    def generate_test_file(self, contract_name: str, contract_abi: List[Dict]) -> str:
        """Generate basic test file for contract"""
        test_template = f"""
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "forge-std/Test.sol";
import "../contracts/{contract_name}.sol";

contract {contract_name}Test is Test {{
    {contract_name} public contract_instance;
    
    function setUp() public {{
        contract_instance = new {contract_name}();
    }}
    
    function testBasicFunctionality() public {{
        assertTrue(address(contract_instance) != address(0));
    }}
}}
"""
        
        test_file = self.test_dir / f"{contract_name}.t.sol"
        with open(test_file, 'w') as f:
            f.write(test_template.strip())
        
        return str(test_file)

# Your original BlockchainDeployer - keeping intact
class BlockchainDeployer:
    """Multi-chain contract deployment"""
    
    def __init__(self, wallet_manager: SecureWalletManager):
        self.wallet_manager = wallet_manager
        self.web3_instances = {}
        self._setup_web3_connections()
    
    def _setup_web3_connections(self):
        """Setup Web3 connections for different networks"""
        for network in NetworkConfig:
            rpc_url = os.getenv(network.value["rpc_key"])
            if rpc_url:
                self.web3_instances[network.value["name"]] = Web3(Web3.HTTPProvider(rpc_url))
                logger.info(f"Connected to {network.value['name']}: {self.web3_instances[network.value['name']].is_connected()}")
    
    async def deploy_contract(self, 
                            contract_name: str,
                            abi: List[Dict],
                            bytecode: str,
                            constructor_args: List = None,
                            network: str = "sepolia",
                            wallet_name: str = "default") -> Dict[str, Any]:
        """Deploy contract to specified network"""
        
        if network not in self.web3_instances:
            raise ValueError(f"Network {network} not configured")
        
        w3 = self.web3_instances[network]
        if not w3.is_connected():
            raise RuntimeError(f"Not connected to {network}")
        
        # Get deployer account
        private_key = self.wallet_manager.get_private_key(wallet_name)
        if not private_key:
            raise ValueError(f"Wallet {wallet_name} not found")
        
        account = Account.from_key(private_key)
        
        # Create contract instance
        contract = w3.eth.contract(abi=abi, bytecode=bytecode)
        
        # Build constructor transaction
        constructor = contract.constructor(*(constructor_args or []))
        
        # Get current gas price and nonce
        gas_price = w3.eth.gas_price
        nonce = w3.eth.get_transaction_count(account.address)
        
        # Build transaction
        transaction = constructor.build_transaction({
            'from': account.address,
            'nonce': nonce,
            'gas': 2000000,
            'gasPrice': gas_price,
        })
        
        # Sign and send transaction
        signed_txn = w3.eth.account.sign_transaction(transaction, private_key)
        tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
        
        # Wait for confirmation
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
        
        deployment_info = {
            "contract_name": contract_name,
            "network": network,
            "address": tx_receipt.contractAddress,
            "tx_hash": tx_hash.hex(),
            "gas_used": tx_receipt.gasUsed,
            "deployer": account.address,
            "block_number": tx_receipt.blockNumber,
            "deployed_at": datetime.utcnow().isoformat()
        }
        
        logger.info(f"Contract {contract_name} deployed to {network} at {tx_receipt.contractAddress}")
        return deployment_info

# Enhanced SecurityScanner with AI integration
class SecurityScanner:
    """Multi-AI security scanning system with real AI analysis"""
    
    def __init__(self, ai_generator: AIContractGenerator):
        self.ai_generator = ai_generator
    
    async def scan_contract_security(self, contract_code: str) -> Dict[str, Any]:
        """Comprehensive security scan using multiple AIs"""
        security_prompt = f"""
You are a smart contract security auditor. Analyze this Solidity contract for security vulnerabilities:

CONTRACT CODE:
{contract_code}

Provide a comprehensive security analysis covering:

1. CRITICAL VULNERABILITIES:
   - Reentrancy attacks
   - Integer overflow/underflow
   - Access control issues
   - Front-running vulnerabilities
   - Timestamp dependence

2. MEDIUM SEVERITY ISSUES:
   - Gas optimization opportunities
   - Unnecessary state changes
   - Inefficient loops
   - Missing events

3. LOW SEVERITY / INFORMATIONAL:
   - Code quality improvements
   - Documentation gaps
   - Style guide compliance

4. RECOMMENDATIONS:
   - Security improvements
   - Best practices implementation
   - Library usage suggestions

Format your response as structured findings with severity levels and remediation suggestions.
"""
        
        # Get security analysis from multiple AIs
        security_results = []
        
        for config in self.ai_generator.ai_configs:
            try:
                if config.name == "openai":
                    result = await self.ai_generator._call_openai(config, security_prompt)
                elif config.name == "anthropic":
                    result = await self.ai_generator._call_anthropic(config, security_prompt)
                elif config.name == "deepseek":
                    result = await self.ai_generator._call_deepseek(config, security_prompt)
                
                security_results.append({
                    "scanner": config.name,
                    "findings": result["full_response"],
                    "timestamp": datetime.utcnow().isoformat()
                })
                
            except Exception as e:
                logger.error(f"Security scan failed for {config.name}: {e}")
        
        return {
            "contract_hash": hashlib.sha256(contract_code.encode()).hexdigest(),
            "scan_results": security_results,
            "scan_timestamp": datetime.utcnow().isoformat()
        }

# Your original DatabaseManager - keeping intact
class DatabaseManager:
    """SQLite database for storing contracts and results"""
    
    def __init__(self, db_path: Path):
        self.db_path = db_path
        self._init_database()
    
    def _init_database(self):
        """Initialize database tables"""
        with self._get_connection() as conn:
            conn.executescript("""
                CREATE TABLE IF NOT EXISTS contracts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    source_code TEXT NOT NULL,
                    abi TEXT,
                    bytecode TEXT,
                    ai_service TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                );
                
                CREATE TABLE IF NOT EXISTS deployments (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    contract_id INTEGER,
                    network TEXT NOT NULL,
                    address TEXT NOT NULL,
                    tx_hash TEXT NOT NULL,
                    deployer TEXT NOT NULL,
                    gas_used INTEGER,
                    deployed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (contract_id) REFERENCES contracts (id)
                );
                
                CREATE TABLE IF NOT EXISTS security_scans (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    contract_id INTEGER,
                    scanner TEXT NOT NULL,
                    findings TEXT NOT NULL,
                    severity_summary TEXT,
                    scanned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (contract_id) REFERENCES contracts (id)
                );
                
                CREATE TABLE IF NOT EXISTS wallets (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT UNIQUE NOT NULL,
                    address TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                );
            """)
    
    @contextmanager
    def _get_connection(self):
        """Get database connection with context management"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        try:
            yield conn
            conn.commit()
        except Exception:
            conn.rollback()
            raise
        finally:
            conn.close()
    
    def save_contract(self, name: str, source_code: str, abi: str = None, 
                     bytecode: str = None, ai_service: str = None) -> int:
        """Save contract to database"""
        with self._get_connection() as conn:
            cursor = conn.execute(
                """INSERT INTO contracts (name, source_code, abi, bytecode, ai_service) 
                   VALUES (?, ?, ?, ?, ?)""",
                (name, source_code, abi, bytecode, ai_service)
            )
            return cursor.lastrowid
    
    def save_deployment(self, contract_id: int, deployment_info: Dict[str, Any]) -> int:
        """Save deployment information"""
        with self._get_connection() as conn:
            cursor = conn.execute(
                """INSERT INTO deployments 
                   (contract_id, network, address, tx_hash, deployer, gas_used) 
                   VALUES (?, ?, ?, ?, ?, ?)""",
                (contract_id, deployment_info["network"], deployment_info["address"],
                 deployment_info["tx_hash"], deployment_info["deployer"], 
                 deployment_info["gas_used"])
            )
            return cursor.lastrowid
    
    def save_security_scan(self, contract_id: int, scanner: str, findings: str) -> int:
        """Save security scan results"""
        with self._get_connection() as conn:
            cursor = conn.execute(
                """INSERT INTO security_scans (contract_id, scanner, findings) 
                   VALUES (?, ?, ?)""",
                (contract_id, scanner, findings)
            )
            return cursor.lastrowid

# Pydantic models for API
class ContractRequest(BaseModel):
    directive: str
    ai_service: Optional[str] = None
    contract_name: Optional[str] = None

class DeploymentRequest(BaseModel):
    contract_id: int
    network: str
    wallet_name: str = "default"
    constructor_args: Optional[List] = None

class WalletRequest(BaseModel):
    wallet_name: str
    mnemonic: Optional[str] = None

# Your main AIContractBuilderSystem - enhanced with proper AI capabilities
class AIContractBuilderSystem:
    """Complete AI-driven contract building system with real AI integration"""
    
    def __init__(self, data_dir: Path = None):
        self.data_dir = data_dir or Path("./ai_contract_data")
        self.data_dir.mkdir(parents=True, exist_ok=True)
        
        # Initialize components
        self.wallet_manager = SecureWalletManager(self.data_dir)
        self.ai_generator = AIContractGenerator()
        self.compiler = ContractCompiler(self.data_dir)
        self.deployer = BlockchainDeployer(self.wallet_manager)
        self.security_scanner = SecurityScanner(self.ai_generator)
        self.database = DatabaseManager(self.data_dir / "contracts.db")
        
        logger.info("AI Contract Builder System initialized with real AI integration")
    
    async def build_contract_full_stack(self, directive: str, 
                                      ai_service: str = None,
                                      contract_name: str = None) -> Dict[str, Any]:
        """Complete contract building pipeline with real AI"""
        
        if not contract_name:
            contract_name = f"AIContract_{int(datetime.utcnow().timestamp())}"
        
        logger.info(f"Starting full-stack build for: {contract_name}")
        
        # Step 1: Generate contract with AI
        logger.info("Step 1: Generating contract with AI...")
        ai_result = await self.ai_generator.generate_contract_with_ai(directive, ai_service)
        contract_code = ai_result["contract_code"]
        
        # Step 2: Compile contract
        logger.info("Step 2: Compiling contract...")
        compilation_result = self.compiler.compile_contract(contract_code, contract_name)
        
        # Get the main contract's compilation data
        main_contract_data = compilation_result.get(contract_name, list(compilation_result.values())[0])
        
        # Step 3: Security scan with AI
        logger.info("Step 3: Running AI security scan...")
        security_result = await self.security_scanner.scan_contract_security(contract_code)
        
        # Step 4: Generate tests
        logger.info("Step 4: Generating test files...")
        test_file = self.compiler.generate_test_file(contract_name, main_contract_data["abi"])
        
        # Step 5: Save to database
        logger.info("Step 5: Saving to database...")
        contract_id = self.database.save_contract(
            name=contract_name,
            source_code=contract_code,
            abi=json.dumps(main_contract_data["abi"]),
            bytecode=main_contract_data["bytecode"],
            ai_service=ai_result["ai_service"]
        )
        
        # Save security scan results
        for scan_result in security_result["scan_results"]:
            self.database.save_security_scan(
                contract_id=contract_id,
                scanner=scan_result["scanner"],
                findings=scan_result["findings"]
            )
        
        return {
            "status": "success",
            "contract_id": contract_id,
            "contract_name": contract_name,
            "ai_service": ai_result["ai_service"],
            "compilation": {
                "abi": main_contract_data["abi"],
                "bytecode": main_contract_data["bytecode"],
                "compiled": True
            },
            "security_scan": security_result,
            "test_file": test_file,
            "source_code": contract_code,
            "build_timestamp": datetime.utcnow().isoformat()
        }
    
    async def deploy_contract_to_network(self, contract_id: int, network: str, 
                                       wallet_name: str = "default",
                                       constructor_args: List = None) -> Dict[str, Any]:
        """Deploy compiled contract to blockchain network"""
        
        # Get contract from database
        with self.database._get_connection() as conn:
            contract_row = conn.execute(
                "SELECT * FROM contracts WHERE id = ?", (contract_id,)
            ).fetchone()
            
            if not contract_row:
                raise ValueError(f"Contract ID {contract_id} not found")
        
        # Parse contract data
        abi = json.loads(contract_row["abi"]) if contract_row["abi"] else []
        bytecode = contract_row["bytecode"]
        contract_name = contract_row["name"]
        
        # Deploy contract
        deployment_info = await self.deployer.deploy_contract(
            contract_name=contract_name,
            abi=abi,
            bytecode=bytecode,
            constructor_args=constructor_args,
            network=network,
            wallet_name=wallet_name
        )
        
        # Save deployment info
        self.database.save_deployment(contract_id, deployment_info)
        
        return deployment_info
    
    def create_wallet(self, wallet_name: str, mnemonic: str = None) -> Dict[str, Any]:
        """Create new wallet"""
        wallet_info = self.wallet_manager.create_wallet(wallet_name, mnemonic)
        
        # Save wallet info to database (without sensitive data)
        with self.database._get_connection() as conn:
            conn.execute(
                "INSERT INTO wallets (name, address) VALUES (?, ?)",
                (wallet_name, wallet_info["address"])
            )
        
        return wallet_info
    
    def get_contract_abi_from_folder(self, contract_path: str) -> Dict[str, Any]:
        """Load contract ABI and interact with deployed contracts"""
        try:
            build_file = Path(contract_path)
            if not build_file.exists():
                build_file = self.data_dir / "build" / f"{contract_path}.json"
                if not build_file.exists():
                    raise FileNotFoundError(f"Contract build file not found: {contract_path}")
            
            with open(build_file, 'r') as f:
                contract_data = json.load(f)
            
            return contract_data
            
        except Exception as e:
            logger.error(f"Error loading contract ABI: {e}")
            raise
    
    def interact_with_deployed_contract(self, network: str, contract_address: str, 
                                      abi: List[Dict], function_name: str, 
                                      args: List = None, wallet_name: str = "default") -> Dict[str, Any]:
        """Interact with deployed contract functions"""
        
        if network not in self.deployer.web3_instances:
            raise ValueError(f"Network {network} not configured")
        
        w3 = self.deployer.web3_instances[network]
        contract = w3.eth.contract(address=contract_address, abi=abi)
        
        # Get function
        if not hasattr(contract.functions, function_name):
            raise ValueError(f"Function {function_name} not found in contract")
        
        function = getattr(contract.functions, function_name)
        
        # Check if function is view/pure (read-only) or requires transaction
        function_abi = next((f for f in abi if f["name"] == function_name), None)
        if not function_abi:
            raise ValueError(f"Function ABI not found for {function_name}")
        
        is_readonly = function_abi.get("stateMutability") in ["view", "pure"]
        
        try:
            if is_readonly:
                # Call view/pure function
                result = function(*(args or [])).call()
                return {
                    "type": "call",
                    "function": function_name,
                    "result": result,
                    "gas_used": 0
                }
            else:
                # Send transaction for state-changing function
                private_key = self.wallet_manager.get_private_key(wallet_name)
                if not private_key:
                    raise ValueError(f"Wallet {wallet_name} not found")
                
                account = Account.from_key(private_key)
                
                # Build transaction
                transaction = function(*(args or [])).build_transaction({
                    'from': account.address,
                    'nonce': w3.eth.get_transaction_count(account.address),
                    'gas': 200000,
                    'gasPrice': w3.eth.gas_price,
                })
                
                # Sign and send
                signed_txn = w3.eth.account.sign_transaction(transaction, private_key)
                tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
                tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
                
                return {
                    "type": "transaction",
                    "function": function_name,
                    "tx_hash": tx_hash.hex(),
                    "gas_used": tx_receipt.gasUsed,
                    "status": tx_receipt.status
                }
                
        except Exception as e:
            logger.error(f"Contract interaction failed: {e}")
            raise

# FastAPI Application
app = FastAPI(
    title="AI Smart Contract Builder",
    description=" AI-powered smart contract building, testing, and deployment system",
    version="1.0.0"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Global system instance
contract_builder = AIContractBuilderSystem()

@app.post("/api/contracts/build")
async def build_contract(request: ContractRequest):
    """Build complete smart contract using AI"""
    try:
        result = await contract_builder.build_contract_full_stack(
            directive=request.directive,
            ai_service=request.ai_service,
            contract_name=request.contract_name
        )
        return result
    except Exception as e:
        logger.error(f"Contract build failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/contracts/{contract_id}/deploy")
async def deploy_contract(contract_id: int, request: DeploymentRequest):
    """Deploy contract to blockchain network"""
    try:
        deployment_info = await contract_builder.deploy_contract_to_network(
            contract_id=contract_id,
            network=request.network,
            wallet_name=request.wallet_name,
            constructor_args=request.constructor_args
        )
        return deployment_info
    except Exception as e:
        logger.error(f"Deployment failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/wallets/create")
async def create_wallet(request: WalletRequest):
    """Create new HD wallet"""
    try:
        wallet_info = contract_builder.create_wallet(
            wallet_name=request.wallet_name,
            mnemonic=request.mnemonic
        )
        return wallet_info
    except Exception as e:
        logger.error(f"Wallet creation failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/contracts/{contract_id}")
async def get_contract(contract_id: int):
    """Get contract information"""
    try:
        with contract_builder.database._get_connection() as conn:
            contract = conn.execute(
                "SELECT * FROM contracts WHERE id = ?", (contract_id,)
            ).fetchone()
            
            if not contract:
                raise HTTPException(status_code=404, detail="Contract not found")
            
            # Get deployments
            deployments = conn.execute(
                "SELECT * FROM deployments WHERE contract_id = ?", (contract_id,)
            ).fetchall()
            
            # Get security scans
            scans = conn.execute(
                "SELECT * FROM security_scans WHERE contract_id = ?", (contract_id,)
            ).fetchall()
            
            return {
                "contract": dict(contract),
                "deployments": [dict(d) for d in deployments],
                "security_scans": [dict(s) for s in scans]
            }
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting contract: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/contracts/interact")
async def interact_with_contract(
    network: str,
    contract_address: str,
    function_name: str,
    args: List = None,
    wallet_name: str = "default"
):
    """Interact with deployed contract"""
    try:
        # This would need contract ABI from database or build files
        return {"message": "Contract interaction endpoint - ABI lookup needed"}
        
    except Exception as e:
        logger.error(f"Contract interaction failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/wallets")
async def list_wallets():
    """List all wallets"""
    try:
        with contract_builder.database._get_connection() as conn:
            wallets = conn.execute("SELECT * FROM wallets").fetchall()
            return [dict(wallet) for wallet in wallets]
    except Exception as e:
        logger.error(f"Error listing wallets: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/contracts")
async def list_contracts():
    """List all contracts"""
    try:
        with contract_builder.database._get_connection() as conn:
            contracts = conn.execute(
                "SELECT id, name, ai_service, created_at FROM contracts ORDER BY created_at DESC"
            ).fetchall()
            return [dict(contract) for contract in contracts]
    except Exception as e:
        logger.error(f"Error listing contracts: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/health")
async def health_check():
    """Health check endpoint"""
    try:
        # Check AI services
        ai_services = []
        for config in contract_builder.ai_generator.ai_configs:
            ai_services.append({
                "name": config.name,
                "status": "configured"
            })
        
        # Check blockchain connections
        network_status = {}
        for network, w3 in contract_builder.deployer.web3_instances.items():
            network_status[network] = "connected" if w3.is_connected() else "disconnected"
        
        return {
            "status": "healthy",
            "ai_services": ai_services,
            "networks": network_status,
            "database": "connected"
        }
        
    except Exception as e:
        logger.error(f"Health check failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/")
async def root():
    """Root endpoint"""
    return {
        "name": "AI Smart Contract Builder",
        "version": "1.0.0",
        "description": "Real AI-powered smart contract building, testing, and deployment system",
        "endpoints": {
            "docs": "/docs",
            "health": "/api/health",
            "build": "/api/contracts/build",
            "deploy": "/api/contracts/{contract_id}/deploy",
            "create_wallet": "/api/wallets/create"
        }
    }

if __name__ == "__main__":
    print("""
    AI Smart Contract Builder System - VERSION1
    
    Required Environment Variables:
    - OPENAI_API_KEY: OpenAI API key
    - ANTHROPIC_API_KEY: Anthropic API key  
    - DEEPSEEK_API_KEY: DeepSeek API key
    - MAINNET_RPC_URL: Ethereum mainnet RPC URL
    - SEPOLIA_RPC_URL: Sepolia testnet RPC URL
    - POLYGON_RPC_URL: Polygon RPC URL
    - BSC_RPC_URL: BSC RPC URL
    - ARBITRUM_RPC_URL: Arbitrum RPC URL
    
    The system will:
    1. Generate contracts using multiple AI services
    2. Compile and test contracts automatically  
    3. Perform AI-powered security scans
    4. Deploy to multiple blockchain networks
    5. Manage HD wallets securely
    6. Store everything in database
    
    Starting production server...
    """)
    
    # Create default wallet if none exists
    try:
        default_wallet = contract_builder.wallet_manager.get_wallet("default")
        if not default_wallet:
            logger.info("Creating default wallet...")
            wallet_info = contract_builder.create_wallet("default")
            logger.info(f"Default wallet created with address: {wallet_info['address']}")
            logger.info("IMPORTANT: Save your mnemonic phrase securely!")
            print(f"\nWallet Mnemonic (SAVE THIS): {wallet_info['mnemonic']}\n")
    except Exception as e:
        logger.error(f"Error creating default wallet: {e}")
    
    # Start server
    uvicorn.run(app, host="0.0.0.0", port=8000, log_level="info")
